```{python}
#| label: figure-3-data
#| cache: false

from bokeh.layouts import gridplot
from bokeh.models import CustomJSTickFormatter, FixedTicker
from scipy.stats import gaussian_kde
from concurrent.futures import ThreadPoolExecutor

# --- load IC50 data ---

ic50 = pd.read_csv(repo_root / "data/inhibition.tsv", sep="\t")
ic50_avg = ic50.groupby("ocnt_batch").agg(
    CYP3A4_pIC50=("CYP3A4_pIC50", "mean"),
    standardized_smiles=("standardized_smiles", "first"),
    activity_status=("activity_status", "first"),
    plate_qc_status=("plate_qc_status", "first"),
    qc_flag_primary=("qc_flag_primary", "first"),
).reset_index()

# --- compute CYP3A4 % remaining from reactivity data ---

react_3a4 = (
    peak_areas[peak_areas["enzyme"] == "CYP3A4"]
    .groupby(["ocnt_batch", "condition"])["area"]
    .mean()
    .reset_index()
    .pivot_table(index="ocnt_batch", columns="condition", values="area")
    .reset_index()
)
react_3a4["pct_remaining"] = (react_3a4["treatment"] / react_3a4["control"]) * 100

# --- join IC50 + reactivity ---

ic50_react = ic50_avg.merge(
    react_3a4[["ocnt_batch", "pct_remaining"]],
    on="ocnt_batch",
    how="inner",
).dropna(subset=["pct_remaining"])

# categorize compounds:
#   - "active": has a fitted pIC50
#   - "qc_fail": no pIC50 due to QC failure (plate, baseline, incomplete, etc.)
#                but activity_status = YES — real activity was detected
#   - "inactive": genuinely inactive (activity_status = NO)
has_pic50 = ic50_react["CYP3A4_pIC50"].notna()
qc_fail = ~has_pic50 & (ic50_react["activity_status"] == "YES")
inactive = ~has_pic50 & ~qc_fail

# assign sentinel pIC50 values for plotting on the log x-axis
ic50_react.loc[inactive, "CYP3A4_pIC50"] = 0.5           # rightmost sentinel
ic50_react.loc[qc_fail, "CYP3A4_pIC50"] = 1.5   # just left of inactive

# convert pIC50 to IC50 (molar)
ic50_react["IC50_M"] = 10 ** (-ic50_react["CYP3A4_pIC50"])

# tooltip labels
ic50_react["pic50_label"] = ic50_react["CYP3A4_pIC50"].apply(lambda v: f"{v:.1f}")
# build a specific QC reason for each failed compound
def qc_reason(row):
    if row["plate_qc_status"] == "FAIL":
        return "Not estimated (plate QC fail)"
    flag = row.get("qc_flag_primary", "")
    if flag and flag != "PASS":
        return f"Not estimated ({flag.lower()})"
    return "Not estimated (QC)"

ic50_react.loc[qc_fail, "pic50_label"] = ic50_react.loc[qc_fail].apply(qc_reason, axis=1)
ic50_react.loc[inactive, "pic50_label"] = "Inactive"

# --- molecule images ---

ic50_react["mol_img"] = ic50_react["standardized_smiles"].apply(smiles_to_svg)

# --- DRC plot thumbnails ---

def copy_drc_thumb(batch_id):
    path = repo_root / f"data/inhibition_drc-plots-webp/{batch_id}_c7111_no-ctrls.webp"
    if not path.exists():
        return ""
    return _save_tooltip(path.read_bytes(), f"drc_{batch_id}.webp")

with ThreadPoolExecutor() as pool:
    ic50_react["drc_img"] = list(pool.map(copy_drc_thumb, ic50_react["ocnt_batch"]))

# --- swarm images ---

ic50_react["swarm_img"] = ic50_react["ocnt_batch"].map(
    lambda b: save_tooltip_svg(make_swarm_svg(b, peak_areas, enzymes=["CYP3A4"]), name=f"swarm_3a4_{b}")
)
```

```{python}
#| label: figure-3-plot
#| cache: false

def make_figure_3():
    x = ic50_react["IC50_M"].values
    y = ic50_react["pct_remaining"].values

    source = ColumnDataSource(data={
        "x": x,
        "y": y,
        "mol_img": ic50_react["mol_img"],
        "swarm_img": ic50_react["swarm_img"],
        "drc_img": ic50_react["drc_img"],
        "batch": ic50_react["ocnt_batch"],
        "pic50": ic50_react["CYP3A4_pIC50"],
        "pic50_label": ic50_react["pic50_label"],
    })

    TOOLTIPS = """
    <div style="width:580px;">
        <div style="text-align:center;"><b>@batch</b> &mdash; pIC50: @pic50_label</div>
        <div style="display:flex; align-items:start; gap:6px;">
            <div><img src="@swarm_img{safe}" height="130"></div>
            <div><img src="@mol_img{safe}" width="150"></div>
            <div><img src="@drc_img{safe}" width="200"></div>
        </div>
    </div>
    """

    lo_y = min(y.min(), 0) - 5
    hi_y = max(y.max(), 105) + 5

    # sentinel positions on the IC50 (molar) axis
    PLATE_QC_SENTINEL = 10 ** -1.5   # ~0.032 M
    INACTIVE_SENTINEL = 10 ** -0.5   # ~0.316 M

    si_formatter = CustomJSTickFormatter(code="""
        const v = tick;
        if (Math.abs(v - 0.316) < 0.05)   return 'Inactive';
        if (Math.abs(v - 0.032) < 0.005)  return 'QC\\nfail';
        if (v >= 1e-3)    return (v * 1e3).toFixed(0) + ' mM';
        if (v >= 1e-6)    return (v * 1e6).toFixed(0) + ' µM';
        if (v >= 1e-9)    return (v * 1e9).toFixed(0) + ' nM';
        if (v >= 1e-12)   return (v * 1e12).toFixed(0) + ' pM';
        return v.toExponential(1) + ' M';
    """)

    # main scatter
    p = bokeh_figure(
        width=520, height=500,
        x_axis_label="CYP3A4 IC50",
        y_axis_label="CYP3A4 (% remaining)",
        x_axis_type="log",
        tools="pan,wheel_zoom,box_zoom,reset,save",
        y_range=(lo_y, hi_y),
    )
    p.xaxis.ticker = FixedTicker(ticks=[
        1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3,
        PLATE_QC_SENTINEL, INACTIVE_SENTINEL,
    ])
    p.xaxis.formatter = si_formatter
    p.xaxis.axis_label_text_font_style = "normal"
    p.yaxis.axis_label_text_font_style = "normal"
    p.grid.visible = False
    p.xaxis.minor_tick_line_color = None
    p.yaxis.minor_tick_line_color = None
    from bokeh.models import Span
    p.add_layout(Span(location=100, dimension="width", line_color="#aaa", line_dash="dashed", line_width=1))
    p.scatter("x", "y", source=source, size=6,
              fill_alpha=0.35, line_color="white", line_width=0.5)
    p.add_tools(HoverTool(tooltips=TOOLTIPS))

    # marginal density: top (IC50, log-space)
    log_x = np.log10(x)
    x_kde = gaussian_kde(log_x)
    log_grid = np.linspace(log_x.min() - 0.3, log_x.max() + 0.3, 300)
    x_grid = 10 ** log_grid
    x_dens = x_kde(log_grid)

    ph = bokeh_figure(
        width=p.width, height=120, x_range=p.x_range,
        x_axis_type="log",
        tools="", toolbar_location=None,
    )
    ph.line(x_grid, x_dens, line_color="steelblue", line_width=1.5)
    ph.varea(x=x_grid, y1=0, y2=x_dens, fill_color="steelblue", fill_alpha=0.15)
    ph.xaxis.visible = False
    ph.yaxis.visible = False
    ph.outline_line_color = None
    ph.grid.visible = False
    ph.min_border_bottom = 0
    ph.min_border_left = p.min_border_left

    # marginal density: right (% remaining)
    y_kde = gaussian_kde(y)
    y_grid = np.linspace(lo_y, hi_y, 300)
    y_dens = y_kde(y_grid)

    pv = bokeh_figure(
        width=120, height=p.height, y_range=p.y_range,
        tools="", toolbar_location=None,
    )
    pv.line(y_dens, y_grid, line_color="steelblue", line_width=1.5)
    pv.harea(y=y_grid, x1=0, x2=y_dens, fill_color="steelblue", fill_alpha=0.15)
    pv.xaxis.visible = False
    pv.yaxis.visible = False
    pv.outline_line_color = None
    pv.grid.visible = False
    pv.min_border_bottom = p.min_border_bottom
    pv.min_border_left = 0

    layout = gridplot([[ph, None], [p, pv]], merge_tools=False)
    script, div = components(layout)
    return HTML(CDN.render() + div + script)

make_figure_3()
```
