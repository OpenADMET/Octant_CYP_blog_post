```{python}
#| label: figure-2-data
#| cache: false


from PIL import Image
from io import BytesIO
from bokeh.layouts import gridplot
from scipy.stats import gaussian_kde
import base64
import cairosvg

# --- load data (pre-filtered by scripts/prepare_data.py) ---

peak_areas = pd.read_csv(repo_root / "data/reactivity.csv")

cpds = peak_areas[["ocnt_batch", "cxsmiles"]].drop_duplicates(subset="ocnt_batch")

# --- summarize replicates ---

summary = (
    peak_areas
    .groupby(["ocnt_batch", "enzyme", "condition"])["area"]
    .mean()
    .reset_index()
    .pivot_table(index=["ocnt_batch", "enzyme"], columns="condition", values="area")
    .reset_index()
)

summary["log2fc"] = np.log2((summary["treatment"] + 1) / (summary["control"] + 1))
summary["pct_remaining"] = (summary["treatment"] / summary["control"]) * 100

# --- pivot for each metric ---

def pivot_metric(metric):
    return (
        summary[["ocnt_batch", "enzyme", metric]]
        .pivot_table(index="ocnt_batch", columns="enzyme", values=metric)
        .reset_index()
        .dropna()
    )

react_log2 = pivot_metric("log2fc")
react_pct = pivot_metric("pct_remaining")

# join SMILES
react_log2 = react_log2.merge(cpds, on="ocnt_batch", how="left").dropna(subset=["cxsmiles"])
react_pct = react_pct.merge(cpds, on="ocnt_batch", how="left").dropna(subset=["cxsmiles"])

# --- render molecule images (WEBP base64 for compact HTML) ---

def smiles_to_webp(smiles, size=(300, 300), quality=90):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return ""
    img = Draw.MolToImage(mol, size=size)
    buf = BytesIO()
    img.save(buf, format="WEBP", quality=quality)
    b64 = base64.b64encode(buf.getvalue()).decode()
    return f"data:image/webp;base64,{b64}"

react_log2["mol_img"] = react_log2["cxsmiles"].apply(smiles_to_webp)
react_pct["mol_img"] = react_pct["cxsmiles"].apply(smiles_to_webp)

# --- swarmplot SVGs for tooltips ---

def _fmt_area(v):
    """Compact number format for peak-area tick labels."""
    if v == 0:
        return "0"
    if v >= 1e6:
        return f"{v / 1e6:.0f}M" if v % 1e6 == 0 else f"{v / 1e6:.1f}M"
    if v >= 1e3:
        return f"{v / 1e3:.0f}k" if v % 1e3 == 0 else f"{v / 1e3:.1f}k"
    return f"{v:.0f}"

def _nice_ticks(y_max, n=3):
    """Return n nice round tick values from 0 to <= y_max."""
    if y_max <= 0:
        return [0]
    raw_step = y_max / (n - 1)
    mag = 10 ** np.floor(np.log10(raw_step))
    for mult in [1, 2, 2.5, 5, 10]:
        step = mult * mag
        if step >= raw_step:
            break
    ticks = np.arange(0, y_max + step * 0.01, step)
    return ticks[ticks <= y_max * 1.01]

def make_swarm_svg(batch, peak_areas_df, enzymes=None, width=None, height=130):
    """Inline SVG swarmplot: control vs treatment raw areas."""
    sub = peak_areas_df[peak_areas_df["ocnt_batch"] == batch]
    if sub.empty:
        return ""

    if enzymes is None:
        enzymes = ["CYP3A4", "CYP2J2"]
    if width is None:
        width = 160 * len(enzymes)
    cond_colors = {"control": "#4477AA", "treatment": "#EE6677"}
    panel_w = width // len(enzymes)
    margin_t, margin_b, margin_l, margin_r = 18, 22, 30, 5
    plot_h = height - margin_t - margin_b

    # shared y-scale across both enzymes
    all_areas = sub["area"].values
    y_max = all_areas.max() * 1.15 if len(all_areas) > 0 and all_areas.max() > 0 else 1

    def sy(v):
        return margin_t + plot_h * (1 - v / y_max)

    ticks = _nice_ticks(y_max)

    parts = [
        f'<svg width="{width}" height="{height}" xmlns="http://www.w3.org/2000/svg"'
        f' style="background:#fafafa; border:1px solid #e0e0e0; border-radius:4px;">'
    ]

    for ei, enz in enumerate(enzymes):
        ox = ei * panel_w
        enz_data = sub[sub["enzyme"] == enz]
        ctrl = enz_data[enz_data["condition"] == "control"]["area"].values
        trt = enz_data[enz_data["condition"] == "treatment"]["area"].values

        # enzyme label
        plot_cx = ox + margin_l + (panel_w - margin_l - margin_r) / 2
        parts.append(
            f'<text x="{plot_cx}" y="{margin_t - 5}" text-anchor="middle"'
            f' font-size="9" font-family="sans-serif" font-weight="bold">{enz}</text>'
        )

        # dot x-positions (shifted right for tick label room)
        dot_area_w = panel_w - margin_l - margin_r
        ctrl_x = ox + margin_l + dot_area_w * 0.33
        trt_x = ox + margin_l + dot_area_w * 0.67

        # y-axis line
        parts.append(
            f'<line x1="{ox + margin_l}" y1="{margin_t}"'
            f' x2="{ox + margin_l}" y2="{sy(0):.1f}"'
            f' stroke="#ccc" stroke-width="0.5"/>'
        )

        # tick marks and labels
        for tv in ticks:
            ty = sy(tv)
            parts.append(
                f'<line x1="{ox + margin_l - 3}" y1="{ty:.1f}"'
                f' x2="{ox + margin_l}" y2="{ty:.1f}"'
                f' stroke="#999" stroke-width="0.5"/>'
            )
            parts.append(
                f'<text x="{ox + margin_l - 5}" y="{ty + 3:.1f}" text-anchor="end"'
                f' font-size="7" font-family="sans-serif" fill="#666">{_fmt_area(tv)}</text>'
            )

        # baseline at zero
        parts.append(
            f'<line x1="{ox + margin_l}" y1="{sy(0):.1f}"'
            f' x2="{ox + panel_w - margin_r}" y2="{sy(0):.1f}"'
            f' stroke="#ccc" stroke-width="0.5"/>'
        )

        # dots
        for cond, cx, vals in [("control", ctrl_x, ctrl), ("treatment", trt_x, trt)]:
            for ji, v in enumerate(vals):
                jitter = (ji - (len(vals) - 1) / 2) * 5
                parts.append(
                    f'<circle cx="{cx + jitter:.1f}" cy="{sy(v):.1f}" r="3.5"'
                    f' fill="{cond_colors[cond]}" opacity="0.75"'
                    f' stroke="white" stroke-width="0.5"/>'
                )

        # condition labels
        parts.append(
            f'<text x="{ctrl_x}" y="{height - 5}" text-anchor="middle"'
            f' font-size="8" font-family="sans-serif" fill="{cond_colors["control"]}">ctrl</text>'
        )
        parts.append(
            f'<text x="{trt_x}" y="{height - 5}" text-anchor="middle"'
            f' font-size="8" font-family="sans-serif" fill="{cond_colors["treatment"]}">trt</text>'
        )

    # y-axis label (left side, rotated)
    mid_y = margin_t + plot_h / 2
    parts.append(
        f'<text x="6" y="{mid_y}" text-anchor="middle"'
        f' font-size="8" font-family="sans-serif" fill="#666"'
        f' transform="rotate(-90,6,{mid_y})">peak area</text>'
    )

    parts.append("</svg>")
    return "".join(parts)

# --- convert SVG strings to compact WEBP base64 ---

def svg_to_webp_b64(svg_str, quality=90):
    if not svg_str:
        return ""
    png_bytes = cairosvg.svg2png(bytestring=svg_str.encode("utf-8"), scale=2)
    img = Image.open(BytesIO(png_bytes))
    buf = BytesIO()
    img.save(buf, format="WEBP", quality=quality)
    b64 = base64.b64encode(buf.getvalue()).decode()
    return f"data:image/webp;base64,{b64}"

# build a lookup once, then map into each dataframe
_swarm_cache = {}
for batch in set(react_log2["ocnt_batch"]) | set(react_pct["ocnt_batch"]):
    _swarm_cache[batch] = svg_to_webp_b64(make_swarm_svg(batch, peak_areas))

react_log2["swarm_img"] = react_log2["ocnt_batch"].map(_swarm_cache)
react_pct["swarm_img"] = react_pct["ocnt_batch"].map(_swarm_cache)

# --- helper: scatter + marginal densities ---

TOOLTIPS = """
<div style="width:340px;">
    <div><img src="@mol_img{safe}" width="200"></div>
    <div><b>@batch</b></div>
    <div style="margin-top:4px;"><img src="@swarm_img{safe}" height="130"></div>
</div>
"""

def marginal_scatter(df, xcol, ycol, xlabel, ylabel, title):
    x = df[xcol].values
    y = df[ycol].values

    source = ColumnDataSource(data={
        "x": x, "y": y,
        "mol_img": df["mol_img"],
        "swarm_img": df["swarm_img"],
        "batch": df["ocnt_batch"],
    })

    lo = min(x.min(), y.min()) - abs(min(x.min(), y.min())) * 0.05 - 1
    hi = max(x.max(), y.max()) + abs(max(x.max(), y.max())) * 0.05 + 1

    # main scatter
    p = bokeh_figure(
        width=500, height=500,
        x_axis_label=xlabel, y_axis_label=ylabel,
        tools="pan,wheel_zoom,box_zoom,reset,save",
        x_range=(lo, hi), y_range=(lo, hi),
    )
    p.xaxis.axis_label_text_font_style = "normal"
    p.yaxis.axis_label_text_font_style = "normal"
    p.scatter("x", "y", source=source, size=6,
              fill_alpha=0.5, line_color="white", line_width=0.5)
    p.add_tools(HoverTool(tooltips=TOOLTIPS))

    # marginal top
    x_kde = gaussian_kde(x)
    x_grid = np.linspace(lo, hi, 300)
    x_dens = x_kde(x_grid)

    ph = bokeh_figure(
        width=p.width, height=120, x_range=p.x_range,
        title=title, tools="", toolbar_location=None,
    )
    ph.line(x_grid, x_dens, line_color="steelblue", line_width=1.5)
    ph.varea(x=x_grid, y1=0, y2=x_dens, fill_color="steelblue", fill_alpha=0.15)
    ph.xaxis.visible = False
    ph.yaxis.visible = False
    ph.outline_line_color = None
    ph.grid.visible = False
    ph.min_border_bottom = 0
    ph.min_border_left = p.min_border_left

    # marginal right
    y_kde = gaussian_kde(y)
    y_grid = np.linspace(lo, hi, 300)
    y_dens = y_kde(y_grid)

    pv = bokeh_figure(
        width=120, height=p.height, y_range=p.y_range,
        tools="", toolbar_location=None,
    )
    pv.line(y_dens, y_grid, line_color="steelblue", line_width=1.5)
    pv.harea(y=y_grid, x1=0, x2=y_dens, fill_color="steelblue", fill_alpha=0.15)
    pv.xaxis.visible = False
    pv.yaxis.visible = False
    pv.outline_line_color = None
    pv.grid.visible = False
    pv.min_border_bottom = p.min_border_bottom
    pv.min_border_left = 0

    layout = gridplot([[ph, None], [p, pv]], merge_tools=False)
    script, div = components(layout)
    return HTML(CDN.render() + div + script)
```

###  (option 1): log2 fold change

```{python}
#| label: figure-2-log2fc
#| cache: false


marginal_scatter(
    react_log2, "CYP3A4", "CYP2J2",
    xlabel="CYP3A4 log\u2082(treatment / control)",
    ylabel="CYP2J2 log\u2082(treatment / control)",
    title="CYP3A4 vs CYP2J2 \u2014 log\u2082 fold change",
)
```

### (option 2): % remaining

```{python}
#| label: figure-2-pct
#| cache: false


marginal_scatter(
    react_pct, "CYP3A4", "CYP2J2",
    xlabel="CYP3A4 (% remaining)",
    ylabel="CYP2J2 (% remaining)",
    title="CYP3A4 vs CYP2J2 \u2014 % remaining",
)
```
